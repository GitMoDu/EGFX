#ifndef _EGFX_MODULES_EGFX_LOGO_SHADERS_h
#define _EGFX_MODULES_EGFX_LOGO_SHADERS_h

#include <EgfxAssets.h>
#include "Constant.h"
#include "Layout.h"

namespace Egfx
{
	namespace Modules
	{
		namespace EgfxLogo
		{
			namespace Shader
			{
				namespace Dither
				{
					// Simple RNG-based ditherer, controlled via chance (0-255)
					class RngDitherer
					{
					private:
						uint16_t Rng = 64;

					public:
						RngDitherer() = default;
						~RngDitherer() = default;

						bool Dither(const uint8_t chance)
						{
							Rng ^= Rng << 7;
							Rng ^= Rng >> 9;
							Rng ^= Rng << 8;

							return chance == 0 ? false : chance >= static_cast<uint8_t>(Rng);
						}
					};
				}

				namespace Source
				{
					using dimension_t = Dimensions::dimension_t;

					template<dimension_t FontWidth, dimension_t FontHeight, bool Monochrome>
					class DotMatrixRgbAlpha
					{
					private:
						static constexpr dimension_t SquareSize = (FontWidth / Dimensions::ColumnCount);

						Dither::RngDitherer Ditherer{};

					public:
						uint16_t FrameCounter = 0;
						uint32_t FrameTime = 0;
						uint8_t Alpha = 255;

					public:
						DotMatrixRgbAlpha() = default;
						~DotMatrixRgbAlpha() = default;

						rgb_color_t Source(const dimension_t x, const dimension_t y)
						{
							const uint8_t indexX = (x / SquareSize) % 3;
							const uint8_t indexY = (y / SquareSize) % 3;

							if (Monochrome)
							{
								return Ditherer.Dither(UINT8_MAX - Alpha) ? Colors::Background : GetMonochrome(indexX, indexY);
							}
							else
							{
								if (Ditherer.Dither(UINT8_MAX - Alpha))
								{
									return Colors::Background;
								}
								else
								{
									const rgb_color_t baseColor = GetColor(indexX, indexY);

									return Rgb::Color(
										(static_cast<uint16_t>(Rgb::R(baseColor)) * Alpha) >> 8,
										(static_cast<uint16_t>(Rgb::G(baseColor)) * Alpha) >> 8,
										(static_cast<uint16_t>(Rgb::B(baseColor)) * Alpha) >> 8);
								}
							}
						}

					private:
						rgb_color_t GetMonochrome(const uint8_t x, const uint8_t y) const
						{
							if ((FrameCounter & 0b1) && (((x + y) + (FrameCounter >> 1)) % 3) != 0)
							{
								return Colors::Background;
							}
							else
							{
								return Colors::Foreground;
							}
						}

						rgb_color_t GetColor(const uint8_t x, const uint8_t y) const
						{
							const uint16_t frameCounter = FrameTime / 35000;
							const uint8_t index = ((x + y * 2) + (frameCounter >> 1)) % 3;

							switch (index)
							{
							case 0:
								return Colors::Color1;
							case 1:
								return Colors::Color2;
							case 2:
							default:
								return Colors::Color3;
							}
						}
					};

					template<dimension_t FontHeight, bool Monochrome>
					class RetroLinesColorAlpha
					{
					private:
						static constexpr dimension_t LineHeight = (FontHeight / Dimensions::LineCount);

						Dither::RngDitherer Ditherer{};

					public:
						rgb_color_t Color1 = Colors::Color1;
						rgb_color_t Color2 = Colors::Color2;
						uint8_t Alpha = 255;

					public:
						RetroLinesColorAlpha() = default;
						~RetroLinesColorAlpha() = default;

						rgb_color_t Source(const dimension_t /*x*/, const dimension_t y)
						{
							if (Ditherer.Dither(UINT8_MAX - Alpha))
							{
								return Colors::Background;
							}
							else
							{
								const dimension_t indexY = (y / LineHeight) % Dimensions::LineCount;

								const ufraction16_t progress = UFraction16::GetScalar<dimension_t>(indexY, Dimensions::LineCount);

								const rgb_color_t interpolatedColor = Rgb::InterpolateLinear(
									progress,
									Color1,
									Color2);

								return Rgb::Color(
									(static_cast<uint16_t>(Rgb::R(interpolatedColor)) * Alpha) >> 8,
									(static_cast<uint16_t>(Rgb::G(interpolatedColor)) * Alpha) >> 8,
									(static_cast<uint16_t>(Rgb::B(interpolatedColor)) * Alpha) >> 8);
							}
						}
					};
				}

				namespace Color
				{
					using dimension_t = Dimensions::dimension_t;

					class ScreenDitherAlpha : public Framework::Shader::Color::BaseShader<dimension_t>
					{
					private:
						using Base = Framework::Shader::Color::BaseShader<dimension_t>;

					private:
						Dither::RngDitherer Ditherer{};

					public:
						uint8_t Alpha = 120;

					public:
						ScreenDitherAlpha() : Base() {}
						~ScreenDitherAlpha() {}

						rgb_color_t Shade(const rgb_color_t color)
						{
							if (Alpha == UINT8_MAX)
							{
								return Base::Shade(color);
							}
							else if (Alpha == 0)
							{
								return Colors::Background;
							}
							else
							{
								if (Ditherer.Dither(Alpha))
								{
									return Base::Shade(color);
								}
								else
								{
									return Colors::Background;
								}
							}
						}
					};

					class ScreenColorAlpha : public Framework::Shader::Color::BaseShader<dimension_t>
					{
					private:
						using Base = Framework::Shader::Color::BaseShader<dimension_t>;

					private:
						Dither::RngDitherer Ditherer{};

					public:
						uint8_t Alpha = 255;

					public:
						ScreenColorAlpha() : Base() {}
						~ScreenColorAlpha() {}

						rgb_color_t Shade(const rgb_color_t color)
						{
							if (Alpha == UINT8_MAX)
							{
								return Base::Shade(color);
							}
							else if (Alpha == 0)
							{
								return Colors::Background;
							}
							else
							{
								return Rgb::Color(
									(static_cast<uint16_t>(Rgb::R(color)) * Alpha) >> 8,
									(static_cast<uint16_t>(Rgb::G(color)) * Alpha) >> 8,
									(static_cast<uint16_t>(Rgb::B(color)) * Alpha) >> 8);
							}
						}
					};

					template<bool Monochrome,
						typename Base = Framework::Shader::Color::BaseShader<dimension_t>
					>
					using ScreenAlpha = typename TypeTraits::TypeConditional::conditional_type<
						ScreenDitherAlpha,
						ScreenColorAlpha,
						Monochrome>::type;
				}


				namespace Pixel
				{
					using dimension_t = Dimensions::dimension_t;

					using ScreenMonochrome = Framework::Shader::Pixel::TemplateColorAndTransform<
						dimension_t,
						Color::ScreenDitherAlpha,
						Framework::Assets::Shader::Transform::Translate<dimension_t>,
						Framework::Shader::Source::StaticColor<dimension_t>
					>;

					using ScreenColor = Framework::Shader::Pixel::TemplateColorAndTransform<
						dimension_t,
						Color::ScreenColorAlpha,
						Framework::Assets::Shader::Transform::Translate<dimension_t>,
						Framework::Shader::Source::SingleColor<dimension_t>
					>;

					template<bool Monochrome>
					using Screen = typename TypeTraits::TypeConditional::conditional_type<
						ScreenMonochrome,
						ScreenColor,
						Monochrome>::type;
				}

				namespace Transform
				{
					using dimension_t = Dimensions::dimension_t;

					template<dimension_t FontWidth, dimension_t FontHeight>
					class RetroLines : public Framework::Shader::Transform::BaseTransform<dimension_t>
					{
					private:
						using RetroLinesLayout = Layout::RetroLinesLayout<FontWidth, FontHeight>;

					private:
						using Base = Framework::Shader::Transform::BaseTransform<dimension_t>;

						static constexpr dimension_t LineHeight = (FontHeight / (Dimensions::LineCount * 2));
						static constexpr dimension_t ActiveHeight = LineHeight - RetroLinesLayout::LineMargin() * 2;
						static constexpr dimension_t InactiveHeight = LineHeight - ActiveHeight;

					public:
						RetroLines() : Base() {}
						~RetroLines() = default;

						static bool Transform(dimension_t& x, dimension_t& y)
						{
							if (!Base::Transform(x, y))
							{
								return false;
							}

							const dimension_t lineY = y % LineHeight;

							if (LineHeight <= RetroLinesLayout::LineMargin() * 2)
							{
								return !(y & 0b1);
							}
							else if (lineY < RetroLinesLayout::LineMargin())
							{
								// Top margin
								return false;
							}
							else if (lineY >= (LineHeight - RetroLinesLayout::LineMargin()))
							{
								// Bottom margin
								return false;
							}
							else
							{
								// Active area
								//y -= InactiveHeight / 2;
								return true;
							}

							return true;
						}
					};

					template<dimension_t FontWidth, dimension_t FontHeight>
					class DotMatrix : public Framework::Shader::Transform::BaseTransform<dimension_t>
					{
					private:
						using DotMatrixLayout = Layout::DotMatrixLayout<FontWidth, FontHeight>;

					private:
						using Base = Framework::Shader::Transform::BaseTransform<dimension_t>;

					protected:
						using Base::Origin;

					public:
						DotMatrix() : Base() {}
						~DotMatrix() = default;

						static bool Transform(dimension_t& x, dimension_t& y)
						{
							if (!Base::Transform(x, y))
							{
								return false;
							}

							if (((x) / 2) % 2 == 0 && ((y + 2) / 2) % 2 == 0)
							{
								y -= 1;
								return true;
							}
							else
							{
								return false;
							}
						}
					};
				}

				namespace Primitive
				{
					using dimension_t = Dimensions::dimension_t;

					template<bool Monochrome>
					using Screen = Framework::Shader::Primitive::TemplateShader<
						dimension_t,
						Pixel::Screen<Monochrome>
					>;


					//template<dimension_t FontWidth, dimension_t FontHeight,
					//	typename ColorSourceType = Framework::Shader::Source::SingleColor<dimension_t>,
					//	typename ColorShaderType = Framework::Shader::Color::NoShader<dimension_t>,
					//	typename TransformShaderType = Framework::Assets::Shader::Transform::Translate<dimension_t>
					//>
					//struct RetroLines : PixelShaderType
					//{
					//	struct RetroLayout
					//	{
					//		using FontLayout = Layout::FontLayout<FontWidth, FontHeight>;
					//		static constexpr pixel_t RowHeight()
					//		{
					//			return FontLayout::RowHeight();
					//		}

					//		static constexpr uint8_t ScanlineMargin() { return 1 + (FontWidth / 3 / 3); }
					//		static constexpr uint8_t ExtraMargin() { return 0; }
					//		static constexpr uint8_t Margin() { return FontLayout::Margin(); }

					//		static constexpr uint8_t LinesPerRow() { return FontLayout::LinesPerRow(); }

					//		static constexpr pixel_t LineHeight()
					//		{
					//			return RowHeight() / LinesPerRow();
					//		}

					//		static constexpr pixel_t LineMargin()
					//		{
					//			return 1 + (LineHeight() / 3);
					//		}

					//		static constexpr pixel_t GetLineYOffset(const uint8_t lineIndex)
					//		{
					//			return static_cast<pixel_t>(pixel_t(lineIndex) * LineHeight());
					//		}
					//	};

					//	ColorSourceType ColorSource{};
					//	ColorShaderType ColorShader{};
					//	TransformShaderType TransformShader{};

					//	pixel_point_t Origin{ 0, 0 };

					//	RetroLines() {}
					//	~RetroLines() = default;

					//	void Prepare(const pixel_t originX, const pixel_t originY)
					//	{
					//		Origin.x = originX;
					//		Origin.y = originY;
					//		TransformShader.Prepare(originX, originY);
					//	}

					//	void Line(IFrameBuffer* framebuffer, const dimension_t x1, const dimension_t y1,
					//		const dimension_t x2, const dimension_t y2)
					//	{
					//		//if (y1 == y2)
					//		//{
					//		//	// Horizontal line optimization.
					//		//	const dimension_t startX = MinValue(x1, x2);
					//		//	const dimension_t endX = MaxValue(x1, x2);
					//		//	for (dimension_t x = startX; x <= endX; x++)
					//		//	{
					//		//		PixelShaderType::Pixel(framebuffer, x, y1);
					//		//	}
					//		//}
					//		//else if (x1 == x2)
					//		//{
					//		//	// Vertical line optimization.
					//		//	const dimension_t startY = MinValue(y1, y2);
					//		//	const dimension_t endY = MaxValue(y1, y2);
					//		//	for (dimension_t y = startY; y <= endY; y++)
					//		//	{
					//		//		PixelShaderType::Pixel(framebuffer, x1, y);
					//		//	}
					//		//}
					//		//else
					//		//{
					//		//	// No-op for non-axis-aligned lines.
					//		//}
					//	}

					//	void TriangleFill(IFrameBuffer* /*framebuffer*/, const dimension_t /*x1*/, const dimension_t /*y1*/,
					//		const dimension_t /*x2*/, const dimension_t /*y2*/,
					//		const dimension_t /*x3*/, const dimension_t /*y3*/)
					//	{
					//		// No-op for triangle fills.
					//	}

					//	void RectangleFill(IFrameBuffer* framebuffer, const dimension_t x1, const dimension_t y1,
					//		const dimension_t x2, const dimension_t /*y2*/)
					//	{
					//		dimension_t coordinatesX;
					//		dimension_t coordinatesY;

					//		for (uint8_t i = 0; i < RetroLayout::LinesPerRow(); i++)
					//		{
					//			const pixel_t y = Origin.y + y1 + RetroLayout::GetLineYOffset(i);

					//			framebuffer->Line(framebuffer,
					//				static_cast<pixel_t>(Origin.x + x1),
					//				static_cast<pixel_t>(y + RetroLayout::LineHeight() / 2),
					//				static_cast<pixel_t>(Origin.x + x2),
					//				static_cast<pixel_t>(y + RetroLayout::LineHeight() / 2));

					//			if (RetroLayout::LineHeight() >= (1 + RetroLayout::LineMargin() * 2))
					//			{
					//				framebuffer->RectangleFill(framebuffer,
					//					static_cast<pixel_t>(Origin.x + x1 + RetroLayout::ScanlineMargin()),
					//					static_cast<pixel_t>(y + RetroLayout::LineMargin()),
					//					static_cast<pixel_t>(Origin.x + x2 - RetroLayout::ScanlineMargin()),
					//					static_cast<pixel_t>(y + RetroLayout::LineHeight() / 2 - 1));
					//				framebuffer->RectangleFill(framebuffer,
					//					static_cast<pixel_t>(Origin.x + x1 + RetroLayout::ScanlineMargin()),
					//					static_cast<pixel_t>(y + RetroLayout::LineHeight() / 2 + 1),
					//					static_cast<pixel_t>(Origin.x + x2 - RetroLayout::ScanlineMargin()),
					//					static_cast<pixel_t>(y + RetroLayout::LineHeight() - RetroLayout::LineMargin()));
					//			}
					//			else if ((RetroLayout::LineHeight() > 2))
					//			{
					//				framebuffer->Line(framebuffer,
					//					static_cast<pixel_t>(Origin.x + x1 + RetroLayout::ScanlineMargin()),
					//					static_cast<pixel_t>(y + 1 + RetroLayout::LineHeight() / 2),
					//					static_cast<pixel_t>(Origin.x + x2 - RetroLayout::ScanlineMargin()),
					//					static_cast<pixel_t>(y + 1 + RetroLayout::LineHeight() / 2));
					//			}
					//		}
					//	}
					//};
				}




				//template<typename dimension_t,
				//	dimension_t FontWidth, dimension_t FontHeight,
				//	typename ColorShaderType = VectorGraphics::Shaders::Color::Single<dimension_t>
				//>
				//struct PrimitiveShaderType
				//{
				//	struct Layout
				//	{
				//		static constexpr uint8_t Margin() { return Dimensions::FontLayout<FontWidth, FontHeight>::Margin(); }

				//		static constexpr pixel_t RowHeight()
				//		{
				//			return Dimensions::FontLayout<FontWidth, FontHeight>::RowHeight();
				//		}

				//		static constexpr uint8_t LinesPerRow() { return Dimensions::FontLayout<FontWidth, FontHeight>::LinesPerRow(); }


				//		static constexpr pixel_t SquareSize()
				//		{
				//			return (FontWidth / Dimensions::ColumnCount);
				//		}

				//		static constexpr pixel_t SquareVisibleSize()
				//		{
				//			return SquareSize() - (Margin() * 2);
				//		}

				//		static constexpr uint8_t SquaresPerRow()
				//		{
				//			return Dimensions::ColumnCount / 2;
				//		}

				//		static constexpr pixel_point_t GetSquareOffset(const uint8_t squareX, const uint8_t squareY)
				//		{
				//			return pixel_point_t{
				//				static_cast<pixel_t>(pixel_t(squareX) * SquareSize()),
				//				static_cast<pixel_t>(pixel_t(squareY) * SquareSize())
				//			};
				//		}
				//	};

				//	ColorShaderType ColorShader{};
				//	pixel_point_t Origin{ 0, 0 };

				//	PrimitiveShaderType() {}
				//	~PrimitiveShaderType() = default;


				//	void PrimitivePrepare(const pixel_t originX, const pixel_t originY)
				//	{
				//		Origin.x = originX;
				//		Origin.y = originY;
				//	}

				//	void PrimitiveRectangleFill(IFrameBuffer* framebuffer, const dimension_t x1, const dimension_t y1,
				//		const dimension_t x2, const dimension_t /*y2*/)
				//	{
				//		const uint8_t xSquares = (x2 - x1) / (Layout::SquareSize() + 0);

				//		for (uint8_t x = 0; x < xSquares; x++)
				//		{
				//			for (uint8_t y = 0; y < Layout::LinesPerRow(); y++)
				//			{
				//				pixel_point_t point = Layout::GetSquareOffset(x, y);

				//				const auto color = ColorShader.ShadeColor(point.x, point.y);

				//				point.x += Origin.x + x1;
				//				point.y += Origin.y + y1;

				//				if (Layout::SquareVisibleSize() > 0)
				//				{
				//					framebuffer->RectangleFill(color,
				//						static_cast<pixel_t>(point.x + Layout::Margin()),
				//						static_cast<pixel_t>(point.y + Layout::Margin()),
				//						static_cast<pixel_t>(point.x + Layout::Margin() + Layout::SquareVisibleSize()),
				//						static_cast<pixel_t>(point.y + Layout::Margin() + Layout::SquareVisibleSize()));
				//				}
				//				else
				//				{
				//					framebuffer->Pixel(color,
				//						static_cast<pixel_t>(point.x + Layout::Margin()),
				//						static_cast<pixel_t>(point.y + Layout::Margin()));
				//				}
				//			}
				//		}
				//	}
				//};



				//template<uint8_t FontHeight, bool Monochrome>
				//using RetroLinesColorShaderType = Shaders::RetroLinesAlphaColor<dimension_t, FontHeight, Monochrome>;

				//template<uint8_t FontWidth, uint8_t FontHeight, bool Monochrome>
				//using RetroLinesPrimitiveShaderType = CodeFonts::LogoFontFamily::Shaders::RetroLines::PrimitiveShaderType<dimension_t, FontWidth, FontHeight, RetroLinesColorShaderType<FontHeight, Monochrome>>;

				//template<uint8_t FontWidth, uint8_t FontHeight, bool Monochrome>
				//using RetroLinesFontDrawerType = CodeFonts::LogoFontFamily::TemplateFont<FontWidth, FontHeight, RetroLinesPrimitiveShaderType<FontWidth, FontHeight, Monochrome>>;

				//template<uint8_t FontWidth, uint8_t FontHeight, bool Monochrome>
				//using DotMatrixColorShaderType = Shaders::DotMatrixDitherRgb<dimension_t, FontWidth, FontHeight, Monochrome>;

				//template<uint8_t FontWidth, uint8_t FontHeight, bool Monochrome>
				//using DotMatrixPrimitiveShaderType = CodeFonts::LogoFontFamily::Shaders::DotMatrix::PrimitiveShaderType<dimension_t, FontWidth, FontHeight, DotMatrixColorShaderType<FontWidth, FontHeight, Monochrome>>;

				//template<uint8_t FontWidth, uint8_t FontHeight, bool Monochrome>
				//using DotMatrixFontDrawerType = CodeFonts::LogoFontFamily::TemplateFont<FontWidth, FontHeight, DotMatrixPrimitiveShaderType<FontWidth, FontHeight, Monochrome>>;
			}
		}
	}
}
#endif